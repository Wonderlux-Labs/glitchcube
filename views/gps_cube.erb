<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üî• Glitch Cube GPS - Live Display</title>
    
    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Courier New', monospace;
            background: #000;
            color: #ff6b35;
            overflow: hidden;
        }
        
        #map {
            height: 100vh;
            width: 100vw;
        }
        
        .info-panel {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.9);
            border: 2px solid #ff6b35;
            border-radius: 10px;
            padding: 20px;
            z-index: 1000;
            max-width: 350px;
            font-size: 16px;
            backdrop-filter: blur(5px);
        }
        
        .info-panel h1 {
            color: #ff6b35;
            margin-bottom: 15px;
            text-align: center;
            font-size: 20px;
        }
        
        .location-info {
            margin-bottom: 10px;
        }
        
        .context {
            font-size: 18px;
            font-weight: bold;
            color: #ffff00;
            text-align: center;
            padding: 10px;
            background: rgba(255, 255, 0, 0.1);
            border-radius: 5px;
            margin: 10px 0;
        }
        
        .coordinates {
            font-size: 12px;
            color: #888;
        }
        
        .destination {
            font-size: 14px;
            color: #00ff00;
            margin: 5px 0;
        }
        
        .status {
            font-size: 12px;
            color: #00ff00;
        }
        
        .offline {
            color: #ff0000;
        }
        
        .simulation-badge {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(255, 165, 0, 0.9);
            color: #000;
            padding: 5px 10px;
            border-radius: 15px;
            font-size: 12px;
            font-weight: bold;
            z-index: 1001;
            border: 2px solid #ff6b35;
            display: none;
        }
        
        .simulation-badge.active {
            display: block;
        }
        
        .pulse {
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }

        /* Visual Mode Styles */
        .temple-mode {
            filter: saturate(0.5) brightness(0.8);
        }

        .man-mode {
            filter: saturate(1.5) brightness(1.2);
        }

        .emergency-mode {
            filter: saturate(1.2) contrast(1.3);
        }

        .service-mode {
            filter: hue-rotate(30deg);
        }

        .landmark-mode {
            filter: contrast(1.1) brightness(1.1);
        }

        /* Proximity Effect Animations */
        .proximity-effect {
            animation: proximityPulse 3s infinite;
        }

        .aura-effect {
            animation: auraGlow 4s infinite;
        }

        .beacon-effect {
            animation: beacon 2s infinite;
        }

        .glow-effect {
            animation: softGlow 5s infinite;
        }

        @keyframes proximityPulse {
            0% { opacity: 0.8; transform: scale(1); }
            50% { opacity: 0.4; transform: scale(1.1); }
            100% { opacity: 0.8; transform: scale(1); }
        }

        @keyframes auraGlow {
            0% { opacity: 0.3; }
            50% { opacity: 0.1; }
            100% { opacity: 0.3; }
        }

        @keyframes beacon {
            0% { opacity: 1; }
            50% { opacity: 0.3; }
            100% { opacity: 1; }
        }

        @keyframes softGlow {
            0% { opacity: 0.2; }
            50% { opacity: 0.4; }
            100% { opacity: 0.2; }
        }

        .route-arrow {
            color: #00ff00 !important;
        }
        
        .proximity-highlight {
            filter: brightness(1.3) saturate(1.2);
        }
        
        .proximity-info {
            animation: proximityAlert 2s infinite;
            color: #39ff14;
            font-size: 12px;
        }
        
        @keyframes proximityAlert {
            0% { opacity: 0.8; }
            50% { opacity: 1; }
            100% { opacity: 0.8; }
        }
    </style>
</head>
<body>
    <div id="map"></div>
    
    <div class="simulation-badge" id="simulationBadge">
        üé≤ SIMULATION MODE
    </div>
    
    <div class="info-panel">
        <h1>üî• GLITCH CUBE</h1>
        <div class="location-info">
            <div class="context" id="context">Loading...</div>
            <div class="coordinates" id="coordinates">Lat: --, Lng: --</div>
            <div class="status" id="status">Connecting...</div>
        </div>
    </div>

    <!-- Leaflet JS -->
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    
    <script>
        // Initialize the map centered on Black Rock City
        const map = L.map('map').setView([40.786958, -119.202994], 14);
        
        // Add OpenStreetMap tiles
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: '¬© OpenStreetMap contributors | Burning Man 2025 | Glitch Cube GPS'
        }).addTo(map);
        
        // Custom icon for the Glitch Cube
        const cubeIcon = L.divIcon({
            className: 'cube-marker pulse',
            html: '<div style="background: #ff6b35; border: 3px solid #fff; border-radius: 50%; width: 24px; height: 24px; display: flex; align-items: center; justify-content: center; font-size: 12px;">üé≤</div>',
            iconSize: [24, 24],
            iconAnchor: [12, 12]
        });

        // Home icon
        const homeIcon = L.divIcon({
            className: 'home-marker',
            html: '<div style="background: #ffff00; border: 2px solid #000; border-radius: 3px; width: 20px; height: 20px; display: flex; align-items: center; justify-content: center; font-size: 12px;">üè†</div>',
            iconSize: [20, 20],
            iconAnchor: [10, 10]
        });
        
        // Markers and layers
        let cubeMarker = null;
        let homeMarker = null;
        let routePolyline = null;
        let routeMarkers = [];
        let routeHistory = [];
        
        // Layer groups
        const streetsLayer = L.layerGroup().addTo(map);
        const landmarksLayer = L.layerGroup().addTo(map);
        const proximityLayer = L.layerGroup().addTo(map);
        
        // Current map mode and effects
        let currentMapMode = 'normal';
        
        // Elements for updating info
        const contextEl = document.getElementById('context');
        const coordinatesEl = document.getElementById('coordinates');
        const statusEl = document.getElementById('status');
        const simulationBadgeEl = document.getElementById('simulationBadge');
        
        // Add HOME marker
        async function addHomeMarker() {
            try {
                const response = await fetch('/api/v1/gps/home');
                const homeData = await response.json();
                
                if (homeData.lat && homeData.lng) {
                    homeMarker = L.marker([homeData.lat, homeData.lng], { icon: homeIcon })
                        .addTo(map)
                        .bindPopup(`üè† HOME<br>${homeData.address}`);
                }
            } catch (error) {
                console.error('Error loading home location:', error);
            }
        }
        
        // Update location function
        async function updateLocation() {
            try {
                const response = await fetch('/api/v1/gps/location');
                const data = await response.json();
                
                if (response.status === 503 || data.error) {
                    // No GPS data available
                    contextEl.textContent = data.message || 'GPS service unavailable';
                    coordinatesEl.textContent = 'No coordinates available';
                    statusEl.textContent = 'GPS tracking offline';
                    statusEl.className = 'status offline';
                    simulationBadgeEl.classList.remove('active');
                    return;
                }
                
                if (data.lat && data.lng) {
                    // Update marker position
                    if (cubeMarker) {
                        cubeMarker.setLatLng([data.lat, data.lng]);
                    } else {
                        cubeMarker = L.marker([data.lat, data.lng], { icon: cubeIcon })
                            .addTo(map)
                            .bindPopup('üé≤ Glitch Cube Location<br>' + (data.address || 'Black Rock City'));
                    }
                    
                    // Update info panel
                    contextEl.textContent = data.context || 'Unknown Location';
                    coordinatesEl.textContent = data.address || `GPS: ${data.lat.toFixed(6)}, ${data.lng.toFixed(6)}`;
                    
                    // Destination display removed - cube movement is unpredictable
                    
                    // Update landmark visibility based on proximity
                    updateLandmarkVisibility({ lat: data.lat, lng: data.lng });
                    
                    // Check for nearby landmarks and show proximity alerts
                    const nearbyLandmarks = landmarks.filter(landmark => {
                        const distance = haversineDistance(data.lat, data.lng, landmark.lat, landmark.lng);
                        return distance <= PROXIMITY_THRESHOLD_METERS;
                    });
                    
                    // Update context styling for proximity
                    if (nearbyLandmarks.length > 0) {
                        const nearest = nearbyLandmarks[0];
                        const distance = Math.round(haversineDistance(data.lat, data.lng, nearest.lat, nearest.lng));
                        contextEl.innerHTML = `${data.context}<br><span style="color: #39ff14; font-size: 12px;">Near ${nearest.name} (${distance}m)</span>`;
                        contextEl.style.borderColor = '#39ff14';
                    } else {
                        contextEl.style.borderColor = '';
                    }
                    
                    statusEl.textContent = `Updated: ${new Date(data.timestamp).toLocaleTimeString()}`;
                    statusEl.className = 'status';
                    
                    // Show simulation badge if in simulation mode
                    if (data.source === 'simulation') {
                        simulationBadgeEl.classList.add('active');
                    } else {
                        simulationBadgeEl.classList.remove('active');
                    }
                    
                    // Add to route history
                    if (routeHistory.length === 0 || 
                        (Math.abs(routeHistory[routeHistory.length - 1].lat - data.lat) > 0.00001 ||
                         Math.abs(routeHistory[routeHistory.length - 1].lng - data.lng) > 0.00001)) {
                        routeHistory.push({
                            lat: data.lat,
                            lng: data.lng,
                            timestamp: data.timestamp,
                            address: data.address
                        });
                        
                        // Keep only last 100 points
                        if (routeHistory.length > 100) {
                            routeHistory = routeHistory.slice(-100);
                        }
                        
                        // Update route display
                        updateRouteDisplay();
                    }
                    
                    // Proximity visual effects removed for cleaner display
                } else {
                    throw new Error('Invalid location data');
                }
                
            } catch (error) {
                console.error('Error fetching location:', error);
                statusEl.textContent = 'Connection lost - retrying...';
                statusEl.className = 'status offline';
            }
        }

        // Update route display
        function updateRouteDisplay() {
            // Remove existing route
            if (routePolyline) {
                map.removeLayer(routePolyline);
            }
            routeMarkers.forEach(marker => map.removeLayer(marker));
            routeMarkers = [];
            
            if (routeHistory.length > 1) {
                const routeCoords = routeHistory.map(point => [point.lat, point.lng]);
                
                // Add gradient polyline
                routePolyline = L.polyline(routeCoords, {
                    color: '#00ff00',
                    weight: 3,
                    opacity: 0.7,
                    smoothFactor: 1.0
                }).addTo(map);
                
                // Add direction arrows
                for (let i = 0; i < routeHistory.length - 1; i += 8) {
                    const point = routeHistory[i];
                    const nextPoint = routeHistory[Math.min(i + 1, routeHistory.length - 1)];
                    
                    const bearing = calculateBearing(
                        point.lat, point.lng,
                        nextPoint.lat, nextPoint.lng
                    );
                    
                    const arrowMarker = L.marker([point.lat, point.lng], {
                        icon: L.divIcon({
                            html: `<div style="transform: rotate(${bearing}deg); color: #00ff00; font-size: 12px;">‚Üí</div>`,
                            iconSize: [12, 12],
                            className: 'route-arrow'
                        })
                    }).addTo(map);
                    routeMarkers.push(arrowMarker);
                }
            }
        }


        // Set map visual mode
        function setMapMode(mode) {
            const mapElement = document.getElementById('map');
            mapElement.classList.remove('temple-mode', 'man-mode', 'emergency-mode', 'service-mode', 'landmark-mode');
            
            if (mode !== 'normal') {
                mapElement.classList.add(`${mode}-mode`);
            }
        }

        // Constants for accurate meter calculations at Burning Man
        const BURNING_MAN_LAT = 40.7831;
        const PROXIMITY_THRESHOLD_METERS = 20; // 20-meter proximity threshold
        const LANDMARK_VISIBILITY_METERS = 20; // Always show landmarks within 20m
        
        // Accurate haversine distance calculation in meters
        function haversineDistance(lat1, lon1, lat2, lon2) {
            const R = 6371000; // Earth's radius in meters
            const dLat = (lat2 - lat1) * Math.PI / 180;
            const dLon = (lon2 - lon1) * Math.PI / 180;
            const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
                Math.sin(dLon/2) * Math.sin(dLon/2);
            return R * 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
        }
        
        // Convert meters to Leaflet radius (degrees) at Burning Man latitude
        function metersToLeafletRadius(meters, lat = BURNING_MAN_LAT) {
            return meters / (111320 * Math.cos(lat * Math.PI / 180));
        }
        
        // Get meters per pixel at current zoom for accurate scaling
        function getMetersPerPixel(zoom, lat = BURNING_MAN_LAT) {
            return 156543.03392 * Math.cos(lat * Math.PI / 180) / Math.pow(2, zoom);
        }
        
        // Helper functions
        function calculateBearing(lat1, lng1, lat2, lng2) {
            const dLon = (lng2 - lng1) * Math.PI / 180;
            const lat1Rad = lat1 * Math.PI / 180;
            const lat2Rad = lat2 * Math.PI / 180;
            
            const y = Math.sin(dLon) * Math.cos(lat2Rad);
            const x = Math.cos(lat1Rad) * Math.sin(lat2Rad) -
                      Math.sin(lat1Rad) * Math.cos(lat2Rad) * Math.cos(dLon);
            
            const bearing = Math.atan2(y, x) * 180 / Math.PI;
            return (bearing + 360) % 360;
        }

        // Store landmarks for distance calculations
        const landmarks = [
            { name: 'Center Camp', lat: 40.786958, lng: -119.202994, icon: 'üèïÔ∏è' },
            { name: 'Temple', lat: 40.791815, lng: -119.196622, icon: 'üèõÔ∏è' },
            { name: 'The Man', lat: 40.786963, lng: -119.203007, icon: 'üî•' }
        ];
        
        // Add landmarks with proper visibility logic
        function addLandmarks() {
            landmarks.forEach(landmark => {
                const marker = L.marker([landmark.lat, landmark.lng], {
                    icon: L.divIcon({
                        html: landmark.icon,
                        iconSize: [24, 24], // Slightly larger for better visibility
                        iconAnchor: [12, 12],
                        className: 'landmark-marker'
                    })
                }).addTo(landmarksLayer);
                
                // Store reference for proximity calculations
                landmark.marker = marker;
                marker.bindPopup(`<strong>${landmark.name}</strong>`);
            });
        }
        
        // Update landmark visibility based on proximity
        function updateLandmarkVisibility(cubeLatLng) {
            const zoom = map.getZoom();
            
            landmarks.forEach(landmark => {
                if (landmark.marker) {
                    const distance = haversineDistance(
                        cubeLatLng.lat, cubeLatLng.lng,
                        landmark.lat, landmark.lng
                    );
                    
                    // Show key landmarks at reasonable zoom levels
                    const shouldShow = zoom >= 13;
                    
                    if (shouldShow && !map.hasLayer(landmark.marker)) {
                        landmark.marker.addTo(landmarksLayer);
                    } else if (!shouldShow && map.hasLayer(landmark.marker)) {
                        landmarksLayer.removeLayer(landmark.marker);
                    }
                    
                    // Highlight landmarks within proximity threshold
                    if (distance <= PROXIMITY_THRESHOLD_METERS) {
                        landmark.marker.setIcon(L.divIcon({
                            html: `<div style="background: #39ff14; border-radius: 50%; padding: 2px;">${landmark.icon}</div>`,
                            iconSize: [28, 28],
                            iconAnchor: [14, 14],
                            className: 'landmark-marker proximity-highlight pulse'
                        }));
                    } else {
                        landmark.marker.setIcon(L.divIcon({
                            html: landmark.icon,
                            iconSize: [24, 24],
                            iconAnchor: [12, 12],
                            className: 'landmark-marker'
                        }));
                    }
                }
            });
        }
        
        // Initialize
        async function initialize() {
            addLandmarks();
            await addHomeMarker();
            await updateLocation();
            
            statusEl.textContent = 'GPS tracking active!';
            statusEl.className = 'status';
            
            // Update every 5 seconds
            setInterval(updateLocation, 5000);
        }
        
        // Start the app
        initialize();
        
        console.log('üî• Glitch Cube GPS Display loaded!');
    </script>
</body>
</html>