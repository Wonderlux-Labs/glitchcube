<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>🔥 Glitch Cube GPS Tracker - Burning Man 2025</title>
    
    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Courier New', monospace;
            background: #000;
            color: #ff6b35;
            overflow: hidden;
        }
        
        #map {
            height: 100vh;
            width: 100vw;
        }
        
        .info-panel {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.9);
            border: 2px solid #ff6b35;
            border-radius: 10px;
            padding: 20px;
            z-index: 1000;
            min-width: 300px;
            font-size: 16px;
            backdrop-filter: blur(5px);
        }
        
        .info-panel h1 {
            color: #ff6b35;
            margin-bottom: 15px;
            text-align: center;
            font-size: 24px;
        }
        
        .location-info {
            margin-bottom: 10px;
        }
        
        .context {
            font-size: 20px;
            font-weight: bold;
            color: #ffff00;
            text-align: center;
            padding: 10px;
            background: rgba(255, 255, 0, 0.1);
            border-radius: 5px;
            margin: 10px 0;
        }
        
        .coordinates {
            font-size: 12px;
            color: #888;
        }
        
        .status {
            font-size: 12px;
            color: #00ff00;
        }
        
        .loading {
            color: #ffaa00;
        }
        
        .offline {
            color: #ff0000;
        }
        
        .pulse {
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }
        
        .legend {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid #ff6b35;
            border-radius: 5px;
            padding: 10px;
            z-index: 1000;
            font-size: 12px;
        }
        
        .legend-item {
            margin: 5px 0;
            display: flex;
            align-items: center;
        }
        
        .legend-color {
            width: 20px;
            height: 3px;
            margin-right: 8px;
        }
        
        .legend-marker {
            width: 15px;
            height: 15px;
            margin-right: 8px;
            text-align: center;
            font-size: 10px;
        }

        .controls {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.9);
            border: 1px solid #ff6b35;
            border-radius: 5px;
            padding: 10px;
            z-index: 1000;
        }

        .controls button {
            background: #ff6b35;
            color: #000;
            border: none;
            padding: 5px 10px;
            margin: 2px;
            border-radius: 3px;
            cursor: pointer;
            font-family: 'Courier New', monospace;
        }

        .controls button:hover {
            background: #ff8c42;
        }

        /* Visual Mode Styles */
        .temple-mode {
            filter: saturate(0.5) brightness(0.8);
        }

        .man-mode {
            filter: saturate(1.5) brightness(1.2);
        }

        .emergency-mode {
            filter: saturate(1.2) contrast(1.3);
        }

        .service-mode {
            filter: hue-rotate(30deg);
        }

        .landmark-mode {
            filter: contrast(1.1) brightness(1.1);
        }

        /* Proximity Effect Animations */
        .proximity-effect {
            animation: proximityPulse 3s infinite;
        }

        .aura-effect {
            animation: auraGlow 4s infinite;
        }

        .beacon-effect {
            animation: beacon 2s infinite;
        }

        .glow-effect {
            animation: softGlow 5s infinite;
        }

        @keyframes proximityPulse {
            0% { opacity: 0.8; transform: scale(1); }
            50% { opacity: 0.4; transform: scale(1.1); }
            100% { opacity: 0.8; transform: scale(1); }
        }

        @keyframes auraGlow {
            0% { opacity: 0.3; }
            50% { opacity: 0.1; }
            100% { opacity: 0.3; }
        }

        @keyframes beacon {
            0% { opacity: 1; }
            50% { opacity: 0.3; }
            100% { opacity: 1; }
        }

        @keyframes softGlow {
            0% { opacity: 0.2; }
            50% { opacity: 0.4; }
            100% { opacity: 0.2; }
        }
    </style>
</head>
<body>
    <div id="map"></div>
    
    <div class="info-panel">
        <h1>🔥 GLITCH CUBE TRACKER</h1>
        <div class="location-info">
            <div class="context" id="context">Loading...</div>
            <div class="coordinates" id="coordinates">Lat: --, Lng: --</div>
            <div class="status" id="status">Connecting to Home Assistant...</div>
        </div>
    </div>
    
    <div class="controls">
        <button onclick="toggleHistory()">Show Route</button>
        <button onclick="centerOnCube()">Center Map</button>
        <button onclick="toggleStreets()">Toggle Streets</button>
        <button onclick="toggleProximityEffects()">Toggle Effects</button>
    </div>

    <div class="legend">
        <div class="legend-item">
            <div class="legend-color" style="background: #ff6b35;"></div>
            <span>Streets</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: #00ff00;"></div>
            <span>Route History</span>
        </div>
        <div class="legend-item">
            <div class="legend-marker" style="background: #ff6b35; border-radius: 50%; border: 2px solid white;"></div>
            <span>Glitch Cube</span>
        </div>
    </div>

    <!-- Leaflet JS -->
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    
    <script>
        // Initialize the map centered on Black Rock City
        const map = L.map('map').setView([40.786958, -119.202994], 14);
        
        // Add OpenStreetMap tiles (free!)
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: '© OpenStreetMap contributors | Burning Man 2025 | Glitch Cube GPS'
        }).addTo(map);
        
        // Custom icon for the Glitch Cube
        const cubeIcon = L.divIcon({
            className: 'cube-marker pulse',
            html: '<div style="background: #ff6b35; border: 3px solid #fff; border-radius: 50%; width: 20px; height: 20px; display: flex; align-items: center; justify-content: center; font-size: 10px;">🎲</div>',
            iconSize: [20, 20],
            iconAnchor: [10, 10]
        });
        
        // Marker for the Glitch Cube
        let cubeMarker = null;
        let routePolyline = null;
        let routeHistory = [];
        
        // Layer groups for organization
        const streetsLayer = L.layerGroup().addTo(map);
        const landmarksLayer = L.layerGroup().addTo(map);
        const proximityLayer = L.layerGroup().addTo(map);
        
        // Current map mode and effects
        let currentMapMode = 'normal';
        let activeEffects = [];
        
        // Elements for updating info
        const contextEl = document.getElementById('context');
        const coordinatesEl = document.getElementById('coordinates');
        const statusEl = document.getElementById('status');
        
        // Update location function with proximity reactions
        async function updateLocation() {
            try {
                const response = await fetch('/api/v1/gps/location');
                const data = await response.json();
                
                if (data.lat && data.lng) {
                    // Update marker position
                    if (cubeMarker) {
                        cubeMarker.setLatLng([data.lat, data.lng]);
                    } else {
                        cubeMarker = L.marker([data.lat, data.lng], { icon: cubeIcon })
                            .addTo(map)
                            .bindPopup('🎲 Glitch Cube Location<br>' + (data.address || 'Black Rock City'));
                    }
                    
                    // Update info panel
                    contextEl.textContent = data.context || 'Unknown Location';
                    coordinatesEl.textContent = `${data.address || 'GPS: ' + data.lat.toFixed(6) + ', ' + data.lng.toFixed(6)}`;
                    statusEl.textContent = `Last updated: ${new Date(data.timestamp).toLocaleTimeString()}`;
                    statusEl.className = 'status';
                    
                    // Handle proximity-based visual reactions
                    if (data.proximity) {
                        applyProximityEffects(data.proximity, data.lat, data.lng);
                        updateProximityInfo(data.proximity);
                    }
                } else {
                    throw new Error('Invalid location data');
                }
                
            } catch (error) {
                console.error('Error fetching location:', error);
                statusEl.textContent = 'Connection lost - retrying...';
                statusEl.className = 'status offline';
            }
        }

        // Load route history
        async function loadRouteHistory() {
            try {
                const response = await fetch('/api/v1/gps/history');
                const data = await response.json();
                
                if (data.history && data.history.length > 0) {
                    routeHistory = data.history.map(point => ({
                        lat: point.lat,
                        lng: point.lng,
                        timestamp: point.timestamp,
                        address: point.address
                    }));
                    
                    console.log(`Loaded ${routeHistory.length} route points`);
                }
            } catch (error) {
                console.error('Error loading route history:', error);
            }
        }

        // Toggle route display
        function toggleHistory() {
            if (routePolyline) {
                map.removeLayer(routePolyline);
                routePolyline = null;
            } else if (routeHistory.length > 0) {
                const routeCoords = routeHistory.map(point => [point.lat, point.lng]);
                routePolyline = L.polyline(routeCoords, {
                    color: '#00ff00',
                    weight: 3,
                    opacity: 0.7
                }).addTo(map);
                
                // Add markers for significant points
                routeHistory.forEach(point => {
                    L.circleMarker([point.lat, point.lng], {
                        radius: 3,
                        color: '#00ff00',
                        fillOpacity: 0.5
                    }).bindPopup(`${point.address}<br>${new Date(point.timestamp).toLocaleString()}`).addTo(map);
                });
            }
        }

        // Center map on cube
        function centerOnCube() {
            if (cubeMarker) {
                map.setView(cubeMarker.getLatLng(), 15);
            }
        }

        // Toggle street display
        function toggleStreets() {
            if (map.hasLayer(streetsLayer)) {
                map.removeLayer(streetsLayer);
            } else {
                map.addLayer(streetsLayer);
            }
        }

        // Toggle proximity effects
        function toggleProximityEffects() {
            if (map.hasLayer(proximityLayer)) {
                map.removeLayer(proximityLayer);
            } else {
                map.addLayer(proximityLayer);
            }
        }
        
        // Add Burning Man landmarks
        function addLandmarks() {
            const landmarks = [
                { name: 'Center Camp (Golden Spike)', lat: 40.786958, lng: -119.202994, icon: '🏕️' },
                { name: 'Temple', lat: 40.7800, lng: -119.2030, icon: '🏛️' },
                { name: 'The Man', lat: 40.7850, lng: -119.2030, icon: '🔥' },
                { name: 'Airport', lat: 40.6622, lng: -119.4341, icon: '✈️' }
            ];
            
            landmarks.forEach(landmark => {
                L.marker([landmark.lat, landmark.lng], {
                    icon: L.divIcon({
                        html: landmark.icon,
                        iconSize: [25, 25],
                        iconAnchor: [12, 12],
                        className: 'landmark-marker'
                    })
                }).addTo(landmarksLayer).bindPopup(`<strong>${landmark.name}</strong>`);
            });
            
            // Add city boundary circle (approximate)
            L.circle([40.786958, -119.202994], {
                color: '#ff6b35',
                fillColor: 'transparent',
                fillOpacity: 0.05,
                radius: 2000, // ~1.25 miles radius
                weight: 2,
                dashArray: '5, 5'
            }).addTo(landmarksLayer);
        }

        // Load real Burning Man street data
        async function loadRealStreets() {
            try {
                statusEl.textContent = 'Loading BRC street grid...';
                statusEl.className = 'status loading';
                
                const response = await fetch('/api/v1/gis/streets');
                const streetsData = await response.json();
                
                // Add streets to map
                L.geoJSON(streetsData, {
                    style: function(feature) {
                        const streetType = feature.properties.type;
                        return {
                            color: streetType === 'radial' ? '#ff6b35' : '#ff8c42',
                            weight: streetType === 'radial' ? 2 : 1.5,
                            opacity: 0.8
                        };
                    },
                    onEachFeature: function(feature, layer) {
                        const props = feature.properties;
                        layer.bindPopup(`
                            <strong>${props.name || 'Street'}</strong><br>
                            Type: ${props.type || 'Unknown'}<br>
                            ${props.width ? `Width: ${props.width}ft` : ''}
                        `);
                    }
                }).addTo(streetsLayer);
                
                console.log('✅ BRC streets loaded successfully');
                
            } catch (error) {
                console.error('Error loading streets:', error);
                // Fallback to basic street grid
                addBasicStreets();
            }
        }

        // Load toilets/portos
        async function loadToilets() {
            try {
                const response = await fetch('/api/v1/gis/toilets');
                const toiletsData = await response.json();
                
                L.geoJSON(toiletsData, {
                    pointToLayer: function(feature, latlng) {
                        return L.marker(latlng, {
                            icon: L.divIcon({
                                className: 'toilet-marker',
                                html: '🚽',
                                iconSize: [16, 16],
                                iconAnchor: [8, 8]
                            })
                        });
                    },
                    onEachFeature: function(feature, layer) {
                        const props = feature.properties;
                        layer.bindPopup(`
                            <strong>🚽 Porto</strong><br>
                            ${props.name || 'Portable Toilet'}
                        `);
                    }
                }).addTo(map);
                
                console.log('✅ BRC toilets loaded successfully');
                
            } catch (error) {
                console.error('Error loading toilets:', error);
            }
        }

        // Add basic street grid fallback
        function addBasicStreets() {
            console.log('Using fallback street grid');
            // Add some basic radial streets (time-based)
            const center = [40.786958, -119.202994];
            const radius = 0.015; // Approximate radius in degrees
            
            for (let hour = 2; hour <= 10; hour++) {
                const angle = (hour * 30 - 90) * Math.PI / 180; // Convert to radians, offset by 90°
                const endLat = center[0] + radius * Math.sin(angle);
                const endLng = center[1] + radius * Math.cos(angle);
                
                L.polyline([center, [endLat, endLng]], {
                    color: '#ff6b35',
                    weight: 2,
                    opacity: 0.6
                }).bindPopup(`${hour}:00`).addTo(streetsLayer);
            }
            
            // Add concentric circles for lettered streets
            const streets = ['Esplanade', 'Atwood', 'Bradbury', 'Cherryh', 'Dick', 'Ellison'];
            streets.forEach((street, index) => {
                const circleRadius = (index + 1) * 300; // meters
                L.circle(center, {
                    color: '#ff8c42',
                    fillColor: 'transparent',
                    radius: circleRadius,
                    weight: 1,
                    opacity: 0.5
                }).bindPopup(street).addTo(streetsLayer);
            });
        }

        // Apply proximity-based visual effects
        function applyProximityEffects(proximity, lat, lng) {
            // Clear existing proximity effects
            proximityLayer.clearLayers();
            
            // Apply map mode changes
            if (proximity.map_mode !== currentMapMode) {
                setMapMode(proximity.map_mode);
                currentMapMode = proximity.map_mode;
            }
            
            // Apply visual effects for nearby landmarks
            proximity.visual_effects.forEach(effect => {
                createVisualEffect(effect, lat, lng);
            });
            
            // Show nearby landmarks as pulsing markers
            proximity.landmarks.forEach(landmark => {
                const marker = L.circleMarker([lat, lng], {
                    radius: Math.max(20, 50 - landmark.distance),
                    color: getEffectColor(landmark.type),
                    fillColor: getEffectColor(landmark.type),
                    fillOpacity: 0.2,
                    weight: 2,
                    className: 'proximity-effect pulse'
                }).addTo(proximityLayer);
                
                marker.bindPopup(`
                    <strong>${landmark.name}</strong><br>
                    Distance: ${Math.round(landmark.distance)}m<br>
                    ${landmark.context}
                `);
            });
            
            // Show nearby porto clusters
            proximity.portos.forEach(porto => {
                L.circleMarker([lat, lng], {
                    radius: 15,
                    color: '#8B4513',
                    fillColor: '#8B4513',
                    fillOpacity: 0.3,
                    weight: 1
                }).bindPopup(`
                    <strong>${porto.name}</strong><br>
                    Distance: ${Math.round(porto.distance)}m
                `).addTo(proximityLayer);
            });
        }

        // Create visual effects based on proximity data
        function createVisualEffect(effect, lat, lng) {
            const effectColor = effect.color || '#ff6b35';
            
            switch (effect.type) {
                case 'aura':
                    // Soft expanding circle for sacred spaces
                    L.circle([lat, lng], {
                        radius: 100,
                        color: effectColor,
                        fillColor: effectColor,
                        fillOpacity: 0.1,
                        weight: 1,
                        dashArray: '5, 5',
                        className: 'aura-effect'
                    }).addTo(proximityLayer);
                    break;
                    
                case 'pulse':
                    // Pulsing circle for high energy areas
                    L.circleMarker([lat, lng], {
                        radius: 30,
                        color: effectColor,
                        fillColor: effectColor,
                        fillOpacity: 0.3,
                        weight: 3,
                        className: 'pulse-effect pulse'
                    }).addTo(proximityLayer);
                    break;
                    
                case 'beacon':
                    // Steady beacon for emergency services
                    L.circleMarker([lat, lng], {
                        radius: 20,
                        color: effectColor,
                        fillColor: effectColor,
                        fillOpacity: 0.5,
                        weight: 2,
                        className: 'beacon-effect'
                    }).addTo(proximityLayer);
                    break;
                    
                case 'glow':
                    // Soft glow for services
                    L.circle([lat, lng], {
                        radius: 50,
                        color: effectColor,
                        fillColor: effectColor,
                        fillOpacity: 0.2,
                        weight: 1,
                        className: 'glow-effect'
                    }).addTo(proximityLayer);
                    break;
            }
        }

        // Get color based on landmark type
        function getEffectColor(type) {
            switch (type) {
                case 'sacred': return '#ffffff';
                case 'center': return '#ff6b35';
                case 'medical': return '#ff0000';
                case 'service': return '#0066ff';
                case 'transport': return '#ffff00';
                default: return '#ff6b35';
            }
        }

        // Set map visual mode
        function setMapMode(mode) {
            const mapElement = document.getElementById('map');
            
            // Remove existing mode classes
            mapElement.classList.remove('temple-mode', 'man-mode', 'emergency-mode', 'service-mode', 'landmark-mode');
            
            // Apply new mode
            if (mode !== 'normal') {
                mapElement.classList.add(`${mode}-mode`);
            }
            
            // Update map tile opacity based on mode
            const tileLayer = map.eachLayer(layer => {
                if (layer instanceof L.TileLayer) {
                    switch (mode) {
                        case 'temple':
                            layer.setOpacity(0.3); // Desaturated for reverence
                            break;
                        case 'emergency':
                            layer.setOpacity(0.7); // High contrast for clarity
                            break;
                        default:
                            layer.setOpacity(1.0);
                    }
                }
            });
        }

        // Update proximity info in the panel
        function updateProximityInfo(proximity) {
            if (proximity.landmarks.length > 0) {
                const primaryLandmark = proximity.landmarks[0];
                contextEl.style.borderColor = getEffectColor(primaryLandmark.type);
                
                // Add proximity alert
                if (primaryLandmark.distance < 100) {
                    const alertEl = document.createElement('div');
                    alertEl.textContent = `⚠️ ${primaryLandmark.context}`;
                    alertEl.style.cssText = 'color: yellow; font-size: 14px; margin-top: 5px;';
                    alertEl.id = 'proximity-alert';
                    
                    // Remove existing alert
                    const existingAlert = document.getElementById('proximity-alert');
                    if (existingAlert) existingAlert.remove();
                    
                    contextEl.parentNode.appendChild(alertEl);
                }
            } else {
                contextEl.style.borderColor = '#ff6b35';
                const existingAlert = document.getElementById('proximity-alert');
                if (existingAlert) existingAlert.remove();
            }
        }
        
        // Initialize everything
        async function initialize() {
            addLandmarks();
            await loadRealStreets();
            await loadToilets();
            await loadRouteHistory();
            await updateLocation();
            
            statusEl.textContent = 'GPS tracking active!';
            statusEl.className = 'status';
            
            // Update location every 10 seconds
            setInterval(updateLocation, 10000);
        }
        
        // Start the app
        initialize();
        
        console.log('🔥 Glitch Cube GPS Tracker loaded!');
        console.log('Tracking via Home Assistant device tracker');
    </script>
</body>
</html>