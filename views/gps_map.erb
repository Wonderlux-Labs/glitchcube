<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üî• Glitch Cube GPS Tracker - Burning Man 2025</title>
    
    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Courier New', monospace;
            background: #000;
            color: #ff6b35;
            overflow: hidden;
        }
        
        #map {
            height: 100vh;
            width: 100vw;
        }
        
        .info-panel {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.85);
            border: 1px solid #ff6b35;
            border-radius: 5px;
            padding: 10px;
            z-index: 1000;
            max-width: 250px;
            font-size: 12px;
            backdrop-filter: blur(3px);
        }
        
        .info-panel h1 {
            color: #ff6b35;
            margin-bottom: 8px;
            text-align: center;
            font-size: 16px;
        }
        
        .location-info {
            margin-bottom: 10px;
        }
        
        .context {
            font-size: 14px;
            font-weight: bold;
            color: #ffff00;
            text-align: center;
            padding: 5px;
            background: rgba(255, 255, 0, 0.1);
            border-radius: 3px;
            margin: 5px 0;
        }
        
        .coordinates {
            font-size: 10px;
            color: #888;
        }
        
        .status {
            font-size: 10px;
            color: #00ff00;
        }
        
        .loading {
            color: #ffaa00;
        }
        
        .offline {
            color: #ff0000;
        }
        
        .pulse {
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }
        
        .legend {
            position: absolute;
            bottom: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid #ff6b35;
            border-radius: 3px;
            padding: 5px;
            z-index: 1000;
            font-size: 10px;
        }
        
        .legend-item {
            margin: 5px 0;
            display: flex;
            align-items: center;
        }
        
        .legend-color {
            width: 20px;
            height: 3px;
            margin-right: 8px;
        }
        
        .legend-marker {
            width: 15px;
            height: 15px;
            margin-right: 8px;
            text-align: center;
            font-size: 10px;
        }

        .controls {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.85);
            border: 1px solid #ff6b35;
            border-radius: 3px;
            padding: 5px;
            z-index: 1000;
            font-size: 11px;
        }

        .controls button {
            background: #ff6b35;
            color: #000;
            border: none;
            padding: 3px 6px;
            margin: 1px;
            border-radius: 2px;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            font-size: 10px;
        }

        .controls button:hover {
            background: #ff8c42;
        }

        /* Visual Mode Styles */
        .temple-mode {
            filter: saturate(0.5) brightness(0.8);
        }

        .man-mode {
            filter: saturate(1.5) brightness(1.2);
        }

        .emergency-mode {
            filter: saturate(1.2) contrast(1.3);
        }

        .service-mode {
            filter: hue-rotate(30deg);
        }

        .landmark-mode {
            filter: contrast(1.1) brightness(1.1);
        }

        /* Proximity Effect Animations */
        .proximity-effect {
            animation: proximityPulse 3s infinite;
        }

        .aura-effect {
            animation: auraGlow 4s infinite;
        }

        .beacon-effect {
            animation: beacon 2s infinite;
        }

        .glow-effect {
            animation: softGlow 5s infinite;
        }

        @keyframes proximityPulse {
            0% { opacity: 0.8; transform: scale(1); }
            50% { opacity: 0.4; transform: scale(1.1); }
            100% { opacity: 0.8; transform: scale(1); }
        }

        @keyframes auraGlow {
            0% { opacity: 0.3; }
            50% { opacity: 0.1; }
            100% { opacity: 0.3; }
        }

        @keyframes beacon {
            0% { opacity: 1; }
            50% { opacity: 0.3; }
            100% { opacity: 1; }
        }

        @keyframes softGlow {
            0% { opacity: 0.2; }
            50% { opacity: 0.4; }
            100% { opacity: 0.2; }
        }
        
        .proximity-highlight {
            filter: brightness(1.3) saturate(1.2);
        }
        
        #proximity-alert {
            animation: proximityAlert 2s infinite;
        }
        
        @keyframes proximityAlert {
            0% { opacity: 0.8; }
            50% { opacity: 1; }
            100% { opacity: 0.8; }
        }
        
        .simulation-badge {
            position: absolute;
            top: 10px;
            right: 170px;
            background: rgba(255, 165, 0, 0.9);
            color: #000;
            padding: 8px 15px;
            border-radius: 20px;
            font-size: 14px;
            font-weight: bold;
            z-index: 1001;
            border: 2px solid #ff6b35;
            display: none;
            backdrop-filter: blur(5px);
        }
        
        .simulation-badge.active {
            display: block;
        }
    </style>
</head>
<body>
    <div id="map"></div>
    
    <div class="simulation-badge" id="simulationBadge">
        üé≤ SIMULATION MODE
    </div>
    
    <div class="info-panel">
        <h1>üî• GLITCH CUBE TRACKER</h1>
        <div class="location-info">
            <div class="context" id="context">Loading...</div>
            <div class="coordinates" id="coordinates">Lat: --, Lng: --</div>
            <div class="status" id="status">Connecting to Home Assistant...</div>
        </div>
    </div>
    
    <div class="controls">
        <button onclick="toggleHistory()">Show Route</button>
        <button onclick="centerOnCube()">Center Map</button>
        <button onclick="toggleStreets()">Toggle Streets</button>
        <button onclick="toggleProximityEffects()">Toggle Effects</button>
    </div>

    <div class="legend">
        <div class="legend-item">
            <div class="legend-color" style="background: #ff6b35;"></div>
            <span>Streets</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: #00ff00;"></div>
            <span>Route History</span>
        </div>
        <div class="legend-item">
            <div class="legend-marker" style="background: #ff6b35; border-radius: 50%; border: 2px solid white;"></div>
            <span>Glitch Cube</span>
        </div>
    </div>

    <!-- Leaflet JS -->
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    
    <script>
        // Initialize the map centered on Black Rock City
        const map = L.map('map').setView([40.786958, -119.202994], 14);
        
        // Add OpenStreetMap tiles (free!)
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: '¬© OpenStreetMap contributors | Burning Man 2025 | Glitch Cube GPS'
        }).addTo(map);
        
        // Custom icon for the Glitch Cube
        const cubeIcon = L.divIcon({
            className: 'cube-marker pulse',
            html: '<div style="background: #ff6b35; border: 3px solid #fff; border-radius: 50%; width: 20px; height: 20px; display: flex; align-items: center; justify-content: center; font-size: 10px;">üé≤</div>',
            iconSize: [20, 20],
            iconAnchor: [10, 10]
        });

        // Home icon
        const homeIcon = L.divIcon({
            className: 'home-marker',
            html: '<div style="background: #ffff00; border: 2px solid #000; border-radius: 3px; width: 20px; height: 20px; display: flex; align-items: center; justify-content: center; font-size: 12px;">üè†</div>',
            iconSize: [20, 20],
            iconAnchor: [10, 10]
        });
        
        // Marker for the Glitch Cube
        let cubeMarker = null;
        let homeMarker = null;
        let routePolyline = null;
        let routeHistory = [];
        
        // Layer groups for organization
        const streetsLayer = L.layerGroup().addTo(map);
        const landmarksLayer = L.layerGroup().addTo(map);
        const proximityLayer = L.layerGroup().addTo(map);
        
        // Current map mode and effects
        let currentMapMode = 'normal';
        let activeEffects = [];
        
        // Elements for updating info
        const contextEl = document.getElementById('context');
        const coordinatesEl = document.getElementById('coordinates');
        const statusEl = document.getElementById('status');
        const simulationBadgeEl = document.getElementById('simulationBadge');
        
        // Update location function with proximity reactions
        async function updateLocation() {
            try {
                const response = await fetch('/api/v1/gps/location');
                const data = await response.json();
                
                if (data.lat && data.lng) {
                    // Update marker position
                    if (cubeMarker) {
                        cubeMarker.setLatLng([data.lat, data.lng]);
                    } else {
                        cubeMarker = L.marker([data.lat, data.lng], { icon: cubeIcon })
                            .addTo(map)
                            .bindPopup('üé≤ Glitch Cube Location<br>' + (data.address || 'Black Rock City'));
                    }
                    
                    // Update info panel
                    contextEl.textContent = data.context || 'Unknown Location';
                    coordinatesEl.textContent = `${data.address || 'GPS: ' + data.lat.toFixed(6) + ', ' + data.lng.toFixed(6)}`;
                    
                    // Update status (no destination info - cube movement is unpredictable)
                    statusEl.textContent = `Last updated: ${new Date(data.timestamp).toLocaleTimeString()}`;
                    statusEl.className = 'status';
                    
                    // Show simulation badge if in simulation mode
                    if (data.source === 'simulation') {
                        simulationBadgeEl.classList.add('active');
                    } else {
                        simulationBadgeEl.classList.remove('active');
                    }
                    
                    // Update landmark visibility based on proximity
                    updateLandmarkVisibility({ lat: data.lat, lng: data.lng });
                    
                    // Check for nearby landmarks and show proximity info
                    const nearbyLandmarks = landmarks.filter(landmark => {
                        const distance = haversineDistance(data.lat, data.lng, landmark.lat, landmark.lng);
                        return distance <= PROXIMITY_THRESHOLD_METERS;
                    });
                    
                    // Update context with proximity information
                    if (nearbyLandmarks.length > 0) {
                        const nearest = nearbyLandmarks[0];
                        const distance = Math.round(haversineDistance(data.lat, data.lng, nearest.lat, nearest.lng));
                        // Add proximity indicator to the existing context panel
                        const proximityAlert = document.getElementById('proximity-alert');
                        if (proximityAlert) proximityAlert.remove();
                        
                        const alertEl = document.createElement('div');
                        alertEl.id = 'proximity-alert';
                        alertEl.innerHTML = `‚ö†Ô∏è Near ${nearest.name} (${distance}m)`;
                        alertEl.style.cssText = 'color: #39ff14; font-size: 12px; margin-top: 5px; background: rgba(57, 255, 20, 0.1); padding: 3px; border-radius: 3px;';
                        contextEl.parentNode.appendChild(alertEl);
                    } else {
                        const proximityAlert = document.getElementById('proximity-alert');
                        if (proximityAlert) proximityAlert.remove();
                    }
                    
                    // Add current position to route history for live tracking
                    if (routeHistory.length === 0 || 
                        (Math.abs(routeHistory[routeHistory.length - 1].lat - data.lat) > 0.00001 ||
                         Math.abs(routeHistory[routeHistory.length - 1].lng - data.lng) > 0.00001)) {
                        routeHistory.push({
                            lat: data.lat,
                            lng: data.lng,
                            timestamp: data.timestamp,
                            address: data.address
                        });
                        
                        // Keep only last 200 points
                        if (routeHistory.length > 200) {
                            routeHistory = routeHistory.slice(-200);
                        }
                        
                        // Auto-update route display if it's shown
                        if (routePolyline) {
                            toggleHistory(); // Hide
                            toggleHistory(); // Show updated
                        }
                    }
                    
                    // Proximity visual effects removed for cleaner display
                } else {
                    throw new Error('Invalid location data');
                }
                
            } catch (error) {
                console.error('Error fetching location:', error);
                statusEl.textContent = 'Connection lost - retrying...';
                statusEl.className = 'status offline';
            }
        }

        // Load route history
        async function loadRouteHistory() {
            try {
                const response = await fetch('/api/v1/gps/history');
                const data = await response.json();
                
                if (data.history && data.history.length > 0) {
                    routeHistory = data.history.map(point => ({
                        lat: point.lat,
                        lng: point.lng,
                        timestamp: point.timestamp,
                        address: point.address
                    }));
                    
                    console.log(`Loaded ${routeHistory.length} route points`);
                }
            } catch (error) {
                console.error('Error loading route history:', error);
            }
        }

        // Toggle route display
        let routeMarkers = [];
        function toggleHistory() {
            if (routePolyline) {
                // Remove existing route
                map.removeLayer(routePolyline);
                routePolyline = null;
                // Remove route markers
                routeMarkers.forEach(marker => map.removeLayer(marker));
                routeMarkers = [];
            } else if (routeHistory.length > 0) {
                const routeCoords = routeHistory.map(point => [point.lat, point.lng]);
                
                // Add gradient polyline for the route
                routePolyline = L.polyline(routeCoords, {
                    color: '#00ff00',
                    weight: 3,
                    opacity: 0.7,
                    smoothFactor: 1.0,
                    lineJoin: 'round'
                }).addTo(map);
                
                // Add direction arrows along the route
                if (routeHistory.length > 1) {
                    for (let i = 0; i < routeHistory.length - 1; i += 5) { // Every 5th point
                        const point = routeHistory[i];
                        const nextPoint = routeHistory[Math.min(i + 1, routeHistory.length - 1)];
                        
                        // Calculate bearing for arrow direction
                        const bearing = calculateBearing(
                            point.lat, point.lng,
                            nextPoint.lat, nextPoint.lng
                        );
                        
                        // Add small arrow marker
                        const arrowMarker = L.marker([point.lat, point.lng], {
                            icon: L.divIcon({
                                html: `<div style="transform: rotate(${bearing}deg); color: #00ff00; font-size: 12px;">‚Üí</div>`,
                                iconSize: [12, 12],
                                className: 'route-arrow'
                            })
                        }).addTo(map);
                        routeMarkers.push(arrowMarker);
                    }
                }
                
                // Add start and end markers
                if (routeHistory.length > 0) {
                    const startPoint = routeHistory[0];
                    const endPoint = routeHistory[routeHistory.length - 1];
                    
                    const startMarker = L.circleMarker([startPoint.lat, startPoint.lng], {
                        radius: 6,
                        color: '#00ff00',
                        fillColor: '#00ff00',
                        fillOpacity: 0.8
                    }).bindPopup(`<strong>Route Start</strong><br>${startPoint.address || 'Location'}<br>${new Date(startPoint.timestamp).toLocaleString()}`).addTo(map);
                    routeMarkers.push(startMarker);
                    
                    const endMarker = L.circleMarker([endPoint.lat, endPoint.lng], {
                        radius: 6,
                        color: '#ff0000',
                        fillColor: '#ff0000',
                        fillOpacity: 0.8
                    }).bindPopup(`<strong>Route End</strong><br>${endPoint.address || 'Location'}<br>${new Date(endPoint.timestamp).toLocaleString()}`).addTo(map);
                    routeMarkers.push(endMarker);
                }
            }
        }
        
        // Constants for accurate meter calculations at Burning Man
        const BURNING_MAN_LAT = 40.7831;
        const PROXIMITY_THRESHOLD_METERS = 20; // 20-meter proximity threshold
        const LANDMARK_VISIBILITY_METERS = 20; // Always show landmarks within 20m
        
        // Accurate haversine distance calculation in meters
        function haversineDistance(lat1, lon1, lat2, lon2) {
            const R = 6371000; // Earth's radius in meters
            const dLat = (lat2 - lat1) * Math.PI / 180;
            const dLon = (lon2 - lon1) * Math.PI / 180;
            const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
                Math.sin(dLon/2) * Math.sin(dLon/2);
            return R * 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
        }
        
        // Convert meters to Leaflet radius (degrees) at Burning Man latitude
        function metersToLeafletRadius(meters, lat = BURNING_MAN_LAT) {
            return meters / (111320 * Math.cos(lat * Math.PI / 180));
        }
        
        // Get meters per pixel at current zoom for accurate scaling
        function getMetersPerPixel(zoom, lat = BURNING_MAN_LAT) {
            return 156543.03392 * Math.cos(lat * Math.PI / 180) / Math.pow(2, zoom);
        }
        
        // Helper function to calculate bearing
        function calculateBearing(lat1, lng1, lat2, lng2) {
            const dLon = (lng2 - lng1) * Math.PI / 180;
            const lat1Rad = lat1 * Math.PI / 180;
            const lat2Rad = lat2 * Math.PI / 180;
            
            const y = Math.sin(dLon) * Math.cos(lat2Rad);
            const x = Math.cos(lat1Rad) * Math.sin(lat2Rad) -
                      Math.sin(lat1Rad) * Math.cos(lat2Rad) * Math.cos(dLon);
            
            const bearing = Math.atan2(y, x) * 180 / Math.PI;
            return (bearing + 360) % 360;
        }

        // Center map on cube
        function centerOnCube() {
            if (cubeMarker) {
                map.setView(cubeMarker.getLatLng(), 15);
            }
        }

        // Toggle street display
        function toggleStreets() {
            if (map.hasLayer(streetsLayer)) {
                map.removeLayer(streetsLayer);
            } else {
                map.addLayer(streetsLayer);
            }
        }

        // Toggle proximity effects
        function toggleProximityEffects() {
            if (map.hasLayer(proximityLayer)) {
                map.removeLayer(proximityLayer);
            } else {
                map.addLayer(proximityLayer);
            }
        }
        
        // Add HOME marker
        async function addHomeMarker() {
            try {
                const response = await fetch('/api/v1/gps/home');
                const homeData = await response.json();
                
                if (homeData.lat && homeData.lng) {
                    homeMarker = L.marker([homeData.lat, homeData.lng], { icon: homeIcon })
                        .addTo(map)
                        .bindPopup(`üè† HOME<br>${homeData.address}`);
                }
            } catch (error) {
                console.error('Error loading home location:', error);
            }
        }
        
        // Store landmarks for distance calculations and visibility
        const landmarks = [
            { name: 'Center Camp (Golden Spike)', lat: 40.786958, lng: -119.202994, icon: 'üèïÔ∏è' },
            { name: 'Temple', lat: 40.791815, lng: -119.196622, icon: 'üèõÔ∏è' },
            { name: 'The Man', lat: 40.786963, lng: -119.203007, icon: 'üî•' },
            { name: 'Airport', lat: 40.6622, lng: -119.4341, icon: '‚úàÔ∏è' }
        ];
        
        // Add Burning Man landmarks with proper visibility logic
        function addLandmarks() {
            landmarks.forEach(landmark => {
                const marker = L.marker([landmark.lat, landmark.lng], {
                    icon: L.divIcon({
                        html: landmark.icon,
                        iconSize: [25, 25],
                        iconAnchor: [12, 12],
                        className: 'landmark-marker'
                    })
                }).addTo(landmarksLayer);
                
                // Store reference for proximity calculations
                landmark.marker = marker;
                marker.bindPopup(`<strong>${landmark.name}</strong>`);
            });
            
            // Add city boundary circle with corrected radius (1.25 miles = 2012 meters)
            L.circle([40.786958, -119.202994], {
                color: '#ff6b35',
                fillColor: 'transparent',
                fillOpacity: 0.05,
                radius: metersToLeafletRadius(2012, 40.786958), // Accurate 1.25 miles in degrees
                weight: 2,
                dashArray: '5, 5'
            }).addTo(landmarksLayer);
        }
        
        // Update landmark visibility based on proximity and zoom
        function updateLandmarkVisibility(cubeLatLng) {
            const zoom = map.getZoom();
            
            landmarks.forEach(landmark => {
                if (landmark.marker) {
                    const distance = haversineDistance(
                        cubeLatLng.lat, cubeLatLng.lng,
                        landmark.lat, landmark.lng
                    );
                    
                    // Always show landmarks within 20m or at moderate zoom levels
                    const shouldShow = zoom >= 13;
                    
                    if (shouldShow && !map.hasLayer(landmark.marker)) {
                        landmark.marker.addTo(landmarksLayer);
                    } else if (!shouldShow && map.hasLayer(landmark.marker)) {
                        landmarksLayer.removeLayer(landmark.marker);
                    }
                    
                    // Highlight landmarks within proximity threshold
                    if (distance <= PROXIMITY_THRESHOLD_METERS) {
                        landmark.marker.setIcon(L.divIcon({
                            html: `<div style="background: #39ff14; border-radius: 50%; padding: 3px;">${landmark.icon}</div>`,
                            iconSize: [30, 30],
                            iconAnchor: [15, 15],
                            className: 'landmark-marker proximity-highlight pulse'
                        }));
                    } else {
                        landmark.marker.setIcon(L.divIcon({
                            html: landmark.icon,
                            iconSize: [25, 25],
                            iconAnchor: [12, 12],
                            className: 'landmark-marker'
                        }));
                    }
                }
            });
        }

        // Load real Burning Man street data
        async function loadRealStreets() {
            try {
                statusEl.textContent = 'Loading BRC street grid...';
                statusEl.className = 'status loading';
                
                const response = await fetch('/api/v1/gis/streets');
                const streetsData = await response.json();
                
                // Add streets to map
                L.geoJSON(streetsData, {
                    style: function(feature) {
                        const streetType = feature.properties.type;
                        return {
                            color: streetType === 'radial' ? '#ff6b35' : '#ff8c42',
                            weight: streetType === 'radial' ? 2 : 1.5,
                            opacity: 0.8
                        };
                    },
                    onEachFeature: function(feature, layer) {
                        const props = feature.properties;
                        layer.bindPopup(`
                            <strong>${props.name || 'Street'}</strong><br>
                            Type: ${props.type || 'Unknown'}<br>
                            ${props.width ? `Width: ${props.width}ft` : ''}
                        `);
                    }
                }).addTo(streetsLayer);
                
                console.log('‚úÖ BRC streets loaded successfully');
                
            } catch (error) {
                console.error('Error loading streets:', error);
                // Fallback to basic street grid
                addBasicStreets();
            }
        }

        // Load toilets/portos
        async function loadToilets() {
            try {
                const response = await fetch('/api/v1/gis/toilets');
                const toiletsData = await response.json();
                
                L.geoJSON(toiletsData, {
                    pointToLayer: function(feature, latlng) {
                        return L.marker(latlng, {
                            icon: L.divIcon({
                                className: 'toilet-marker',
                                html: 'üöΩ',
                                iconSize: [16, 16],
                                iconAnchor: [8, 8]
                            })
                        });
                    },
                    onEachFeature: function(feature, layer) {
                        const props = feature.properties;
                        layer.bindPopup(`
                            <strong>üöΩ Porto</strong><br>
                            ${props.name || 'Portable Toilet'}
                        `);
                    }
                }).addTo(map);
                
                console.log('‚úÖ BRC toilets loaded successfully');
                
            } catch (error) {
                console.error('Error loading toilets:', error);
            }
        }

        // Add basic street grid fallback
        function addBasicStreets() {
            console.log('Using fallback street grid');
            // Add some basic radial streets (time-based)
            const center = [40.786958, -119.202994];
            const radius = 0.015; // Approximate radius in degrees
            
            for (let hour = 2; hour <= 10; hour++) {
                const angle = (hour * 30 - 90) * Math.PI / 180; // Convert to radians, offset by 90¬∞
                const endLat = center[0] + radius * Math.sin(angle);
                const endLng = center[1] + radius * Math.cos(angle);
                
                L.polyline([center, [endLat, endLng]], {
                    color: '#ff6b35',
                    weight: 2,
                    opacity: 0.6
                }).bindPopup(`${hour}:00`).addTo(streetsLayer);
            }
            
            // Add concentric circles for lettered streets
            const streets = ['Esplanade', 'Atwood', 'Bradbury', 'Cherryh', 'Dick', 'Ellison'];
            streets.forEach((street, index) => {
                const circleRadius = (index + 1) * 300; // meters
                L.circle(center, {
                    color: '#ff8c42',
                    fillColor: 'transparent',
                    radius: circleRadius,
                    weight: 1,
                    opacity: 0.5
                }).bindPopup(street).addTo(streetsLayer);
            });
        }

        // Apply proximity-based visual effects
        function applyProximityEffects(proximity, lat, lng) {
            // Clear existing proximity effects
            proximityLayer.clearLayers();
            
            // Get current zoom level to scale effects
            const zoom = map.getZoom();
            const scaleFactor = Math.max(0.2, Math.min(1, (zoom - 12) / 4)); // Scale between zoom 12-16
            
            // Apply map mode changes
            if (proximity.map_mode !== currentMapMode) {
                setMapMode(proximity.map_mode);
                currentMapMode = proximity.map_mode;
            }
            
            // Only show effects if zoomed in enough
            if (zoom >= 13) {
                // Apply visual effects for nearby landmarks
                proximity.visual_effects.forEach(effect => {
                    createVisualEffect(effect, lat, lng, scaleFactor);
                });
                
                // Show nearby landmarks as pulsing markers
                proximity.landmarks.forEach(landmark => {
                    const baseRadius = Math.max(20, 50 - landmark.distance);
                    const marker = L.circleMarker([lat, lng], {
                        radius: baseRadius * scaleFactor,
                        color: getEffectColor(landmark.type),
                        fillColor: getEffectColor(landmark.type),
                        fillOpacity: 0.2 * scaleFactor,
                        weight: 2,
                        className: 'proximity-effect pulse'
                    }).addTo(proximityLayer);
                    
                    marker.bindPopup(`
                        <strong>${landmark.name}</strong><br>
                        Distance: ${Math.round(landmark.distance)}m<br>
                        ${landmark.context}
                    `);
                });
                
                // Show nearby porto clusters
                proximity.portos.forEach(porto => {
                    L.circleMarker([lat, lng], {
                        radius: 15 * scaleFactor,
                        color: '#8B4513',
                        fillColor: '#8B4513',
                        fillOpacity: 0.3 * scaleFactor,
                        weight: 1
                    }).bindPopup(`
                        <strong>${porto.name}</strong><br>
                        Distance: ${Math.round(porto.distance)}m
                    `).addTo(proximityLayer);
                });
            }
        }

        // Create visual effects based on proximity data with accurate meter calculations
        function createVisualEffect(effect, lat, lng, scaleFactor = 1) {
            const effectColor = effect.color || '#ff6b35';
            const zoom = map.getZoom();
            
            switch (effect.type) {
                case 'aura':
                    // 25-meter aura effect for sacred spaces
                    L.circle([lat, lng], {
                        radius: metersToLeafletRadius(25, lat) * scaleFactor,
                        color: effectColor,
                        fillColor: effectColor,
                        fillOpacity: 0.1 * scaleFactor,
                        weight: 1,
                        dashArray: '5, 5',
                        className: 'aura-effect'
                    }).addTo(proximityLayer);
                    break;
                    
                case 'pulse':
                    // 15-meter pulse effect for high energy areas
                    const pulseRadiusPixels = 15 / getMetersPerPixel(zoom, lat);
                    L.circleMarker([lat, lng], {
                        radius: Math.max(15, pulseRadiusPixels * scaleFactor),
                        color: effectColor,
                        fillColor: effectColor,
                        fillOpacity: 0.3 * scaleFactor,
                        weight: 3 * scaleFactor,
                        className: 'pulse-effect pulse'
                    }).addTo(proximityLayer);
                    break;
                    
                case 'beacon':
                    // 10-meter beacon for emergency services
                    const beaconRadiusPixels = 10 / getMetersPerPixel(zoom, lat);
                    L.circleMarker([lat, lng], {
                        radius: Math.max(10, beaconRadiusPixels * scaleFactor),
                        color: effectColor,
                        fillColor: effectColor,
                        fillOpacity: 0.5 * scaleFactor,
                        weight: 2 * scaleFactor,
                        className: 'beacon-effect'
                    }).addTo(proximityLayer);
                    break;
                    
                case 'glow':
                    // 12-meter glow for services
                    L.circle([lat, lng], {
                        radius: metersToLeafletRadius(12, lat) * scaleFactor,
                        color: effectColor,
                        fillColor: effectColor,
                        fillOpacity: 0.2 * scaleFactor,
                        weight: 1,
                        className: 'glow-effect'
                    }).addTo(proximityLayer);
                    break;
            }
        }

        // Get color based on landmark type
        function getEffectColor(type) {
            switch (type) {
                case 'sacred': return '#ffffff';
                case 'center': return '#ff6b35';
                case 'medical': return '#ff0000';
                case 'service': return '#0066ff';
                case 'transport': return '#ffff00';
                default: return '#ff6b35';
            }
        }

        // Set map visual mode
        function setMapMode(mode) {
            const mapElement = document.getElementById('map');
            
            // Remove existing mode classes
            mapElement.classList.remove('temple-mode', 'man-mode', 'emergency-mode', 'service-mode', 'landmark-mode');
            
            // Apply new mode
            if (mode !== 'normal') {
                mapElement.classList.add(`${mode}-mode`);
            }
            
            // Update map tile opacity based on mode
            const tileLayer = map.eachLayer(layer => {
                if (layer instanceof L.TileLayer) {
                    switch (mode) {
                        case 'temple':
                            layer.setOpacity(0.3); // Desaturated for reverence
                            break;
                        case 'emergency':
                            layer.setOpacity(0.7); // High contrast for clarity
                            break;
                        default:
                            layer.setOpacity(1.0);
                    }
                }
            });
        }

        // Update proximity info in the panel
        function updateProximityInfo(proximity) {
            if (proximity.landmarks.length > 0) {
                const primaryLandmark = proximity.landmarks[0];
                contextEl.style.borderColor = getEffectColor(primaryLandmark.type);
                
                // Add proximity alert
                if (primaryLandmark.distance < 100) {
                    const alertEl = document.createElement('div');
                    alertEl.textContent = `‚ö†Ô∏è ${primaryLandmark.context}`;
                    alertEl.style.cssText = 'color: yellow; font-size: 14px; margin-top: 5px;';
                    alertEl.id = 'proximity-alert';
                    
                    // Remove existing alert
                    const existingAlert = document.getElementById('proximity-alert');
                    if (existingAlert) existingAlert.remove();
                    
                    contextEl.parentNode.appendChild(alertEl);
                }
            } else {
                contextEl.style.borderColor = '#ff6b35';
                const existingAlert = document.getElementById('proximity-alert');
                if (existingAlert) existingAlert.remove();
            }
        }
        
        // Initialize everything
        async function initialize() {
            addLandmarks();
            await addHomeMarker();
            await loadRealStreets();
            await loadToilets();
            await loadRouteHistory();
            await updateLocation();
            
            statusEl.textContent = 'GPS tracking active!';
            statusEl.className = 'status';
            
            // Update location every 10 seconds
            setInterval(updateLocation, 10000);
        }
        
        // Start the app
        initialize();
        
        console.log('üî• Glitch Cube GPS Tracker loaded!');
        console.log('Tracking via Home Assistant device tracker');
    </script>
</body>
</html>