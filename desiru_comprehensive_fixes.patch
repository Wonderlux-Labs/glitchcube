From: Eric Stiens <eric@example.com>
Date: Sat, 3 Aug 2025 20:35:00 -0500
Subject: [PATCH] Fix OpenRouter adapter and ReAct module issues

This patch fixes several critical issues in Desiru:

1. OpenRouter adapter incorrectly calling open_router gem's complete method
2. ReAct module not properly including tool descriptions in prompts
3. ReAct module not handling Class-based tools correctly

---
 lib/desiru/models/open_router.rb | 76 ++++++++++++++++++++++----------
 lib/desiru/modules/react.rb      | 72 +++++++++++++++++++++++++++-----
 2 files changed, 114 insertions(+), 34 deletions(-)

diff --git a/lib/desiru/models/open_router.rb b/lib/desiru/models/open_router.rb
index 1234567..abcdefg 100644
--- a/lib/desiru/models/open_router.rb
+++ b/lib/desiru/models/open_router.rb
@@ -36,17 +36,18 @@ module Desiru
       def perform_completion(messages, options)
         model = options[:model] || @config[:model] || DEFAULT_MODEL
         temperature = options[:temperature] || @config[:temperature] || 0.7
         max_tokens = options[:max_tokens] || @config[:max_tokens] || 4096
 
-        # Prepare request parameters
+        # Prepare parameters for open_router gem
+        # The gem expects messages as first param, other options as named params
         params = {
           model: model,
-          messages: messages,
-          temperature: temperature,
-          max_tokens: max_tokens
+          extras: {
+            temperature: temperature,
+            max_tokens: max_tokens
+          }
         }
 
         # Add provider-specific options if needed
-        params[:provider] = options[:provider] if options[:provider]
+        params[:providers] = [options[:provider]] if options[:provider]
 
         # Add response format if specified
-        params[:response_format] = options[:response_format] if options[:response_format]
+        params[:extras][:response_format] = options[:response_format] if options[:response_format]
 
         # Add tools if provided (for models that support function calling)
         if options[:tools]
-          params[:tools] = options[:tools]
-          params[:tool_choice] = options[:tool_choice] if options[:tool_choice]
+          params[:extras][:tools] = options[:tools]
+          params[:extras][:tool_choice] = options[:tool_choice] if options[:tool_choice]
         end
 
-        # Make API call
-        response = @client.complete(params)
+        # Make API call with correct parameter structure
+        response = @client.complete(messages, **params)
 
         # Format response
         format_response(response, model)
       rescue StandardError => e
         handle_api_error(e)
       end
 
       def stream_complete(prompt, **options, &block)
         messages = prepare_messages(prompt, options[:messages])
         model = options[:model] || @config[:model] || DEFAULT_MODEL
         temperature = options[:temperature] || @config[:temperature] || 0.7
         max_tokens = options[:max_tokens] || @config[:max_tokens] || 4096
 
-        # Prepare streaming request
+        # Prepare parameters for open_router gem streaming
         params = {
           model: model,
-          messages: messages,
-          temperature: temperature,
-          max_tokens: max_tokens,
-          stream: true
+          stream: true,
+          extras: {
+            temperature: temperature,
+            max_tokens: max_tokens
+          }
         }
 
         # Stream response
-        @client.complete(params) do |chunk|
+        @client.complete(messages, **params) do |chunk|
           if chunk.dig('choices', 0, 'delta', 'content')
             content = chunk.dig('choices', 0, 'delta', 'content')
             block.call(content) if block_given?
           end
         end
       rescue StandardError => e
         handle_api_error(e)
       end
 
       private
@@ -145,17 +151,30 @@ module Desiru
 
       def handle_api_error(error)
         case error
+        when ::OpenRouter::ServerError
+          # OpenRouter-specific server errors
+          if error.message.include?('401') || error.message.downcase.include?('unauthorized')
+            raise ::Desiru::AuthenticationError, 'Invalid OpenRouter API key'
+          elsif error.message.include?('429') || error.message.downcase.include?('rate limit')
+            raise ::Desiru::RateLimitError, 'OpenRouter API rate limit exceeded'
+          elsif error.message.include?('402') || error.message.downcase.include?('payment')
+            raise ::Desiru::ModelError, 'OpenRouter payment required - check your account balance'
+          else
+            raise ::Desiru::ModelError, "OpenRouter API error: #{error.message}"
+          end
         when ::Faraday::UnauthorizedError
-          raise AuthenticationError, 'Invalid OpenRouter API key'
+          raise ::Desiru::AuthenticationError, 'Invalid OpenRouter API key'
         when ::Faraday::BadRequestError
-          raise InvalidRequestError, "Invalid request: #{error.message}"
+          raise ::Desiru::ModelError, "Invalid request: #{error.message}"
         when ::Faraday::TooManyRequestsError
-          raise RateLimitError, 'OpenRouter API rate limit exceeded'
-        when ::Faraday::PaymentRequiredError
-          raise APIError, 'OpenRouter payment required - check your account balance'
+          raise ::Desiru::RateLimitError, 'OpenRouter API rate limit exceeded'
+        when ::Faraday::Error
+          # Generic Faraday errors
+          raise ::Desiru::NetworkError, "Network error: #{error.message}"
         else
-          raise APIError, "OpenRouter API error: #{error.message}"
+          # Catch-all for unexpected errors
+          raise ::Desiru::ModelError, "Unexpected API error: #{error.class} - #{error.message}"
         end
       end
     end
   end
 end
diff --git a/lib/desiru/modules/react.rb b/lib/desiru/modules/react.rb
index 1234567..abcdefg 100644
--- a/lib/desiru/modules/react.rb
+++ b/lib/desiru/modules/react.rb
@@ -5,14 +5,37 @@ require_relative 'chain_of_thought'
 
 module Desiru
   module Modules
+    # Custom ChainOfThought for ReAct that includes tool descriptions in system prompt
+    class ReActChainOfThought < ChainOfThought
+      def initialize(signature, tool_descriptions: '', **options)
+        @tool_descriptions = tool_descriptions
+        super(signature, **options)
+      end
+      
+      protected
+      
+      def build_system_prompt
+        base_prompt = super
+        
+        # Insert tool descriptions after the signature description
+        if @tool_descriptions && !@tool_descriptions.empty?
+          parts = base_prompt.split("\n\n", 3)
+          parts.insert(1, "Available tools:\n#{@tool_descriptions}")
+          parts.join("\n\n")
+        else
+          base_prompt
+        end
+      end
+    end
+    
     # ReAct (Reasoning and Acting) module for tool-using AI agents
     # This module allows the language model to iteratively reason about a task
     # and use tools to gather information before producing a final answer
     class ReAct < Desiru::Module
       attr_reader :max_iterations, :tools, :react_module, :extract_module
 
       def initialize(signature, tools: [], max_iterations: 5, model: nil)
         super(signature, model: model)
         @tools = normalize_tools(tools)
         @max_iterations = max_iterations
 
         # Build the ReAct signature for reasoning and tool selection
         react_signature = build_react_signature
-        @react_module = ChainOfThought.new(react_signature, model: @model)
+        @react_module = ReActChainOfThought.new(react_signature, model: @model, tool_descriptions: format_tool_descriptions)
 
         # Build extraction signature for final output
         extract_signature = build_extract_signature
         @extract_module = ChainOfThought.new(extract_signature, model: @model)
       end
 
       def forward(inputs)
@@ -103,8 +126,13 @@ module Desiru
         react_sig = "#{input_fields}, trajectory -> next_thought, next_tool_name, next_tool_args"
 
         # Add instructions
+        tool_descriptions = format_tool_descriptions
+        
+        # Debug logging
+        Desiru.logger.info "Available tools in ReAct: #{@tools.keys.inspect}"
+        Desiru.logger.info "Tool descriptions:\n#{tool_descriptions}"
+        
         instructions = <<~INST
           You are an AI agent that can use tools to accomplish tasks.
 
           Available tools:
-          #{format_tool_descriptions}
+          #{tool_descriptions}
 
           Based on the input and trajectory so far, reason about what to do next.
           Then select a tool to use and provide the arguments for that tool.
 
           When you have gathered enough information to answer the question,
           use the "finish" tool to complete the task.
         INST
 
-        Signature.new(react_sig, descriptions: { 'next_thought' => instructions })
+        # Include instructions in both system and field description
+        Signature.new(react_sig, 
+          descriptions: { 
+            'next_thought' => instructions,
+            'system' => instructions 
+          }
+        )
       end
 
       def build_extract_signature
@@ -250,23 +287,36 @@ module Desiru
 
       def execute_tool(tool_name, args)
         tool = tools[tool_name]
 
         raise "Unknown tool: #{tool_name}" unless tool
 
-        # Call the tool with arguments
-        if tool.arity.zero?
-          tool.call
-        elsif tool.arity == 1 && args.is_a?(Hash)
-          # Pass args as keyword arguments if possible
-          if tool.respond_to?(:parameters)
-            param_types = tool.parameters.map(&:first)
-            if param_types.include?(:keyreq) || param_types.include?(:key)
-              tool.call(**args)
+        # Handle different types of tools
+        if tool.is_a?(Class) && tool.respond_to?(:call)
+          # Class-based tool - call the class method with keyword args
+          tool.call(**args)
+        elsif tool.respond_to?(:arity)
+          # Method or Proc-based tool
+          if tool.arity.zero?
+            tool.call
+          elsif tool.arity == 1 && args.is_a?(Hash)
+            # Pass args as keyword arguments if possible
+            if tool.respond_to?(:parameters)
+              param_types = tool.parameters.map(&:first)
+              if param_types.include?(:keyreq) || param_types.include?(:key)
+                tool.call(**args)
+              else
+                tool.call(args)
+              end
             else
               tool.call(args)
             end
           else
-            tool.call(args)
+            # Pass args as positional arguments
+            tool.call(*args.values)
           end
         else
-          # Pass args as positional arguments
-          tool.call(*args.values)
+          # Fallback - just try to call it
+          tool.call(**args)
         end
       end
 
       # Support for truncating trajectory if it gets too long
       def truncate_trajectory(trajectory, max_length: 3000)
-- 
2.39.0